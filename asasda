# -*- coding: utf-8 -*-
"""
PROSEGUR - Subida de tablas unificada (Jupyter / Airflow)
-------------------------------------------------------------------------------
Basado en 02_subida_tablas_britimp_unificado.py, adaptado para PROSEGUR.

Este script orquesta la carga de los archivos consolidados PROSEGUR:
  - PROSEGUR_EFECTBANCO.csv
  - PROSEGUR_EFECTATM.csv
  - PROSEGUR_INVENTARIO_ATM.csv
  - PROSEGUR_INVENTARIO_BCO.csv
  - PROSEGUR_BULTOSATM.csv
  - PROSEGUR_BULTOSBANCO.csv

a las tablas en AT_CMDTS:
  - PLXS_EC_BCO_PROSEGUR_2025
  - PLXS_PROSEGUR_EFECTATM
  - PLXS_PROSEGUR_INVENTARIO_ATM
  - PLXS_PROSEGUR_INVENTARIO_BANCO
  - PLXS_PROSEGUR_BULTOSATM
  - PLXS_PROSEGUR_BULTOSBANCO

La FECHA_CREACION se agrega aquí al momento de la carga.
-------------------------------------------------------------------------------
"""

import os
from datetime import datetime
from typing import Optional, Tuple, List

import pandas as pd

from sqlConn import sqlConn
from mail import email


# ----------------------------------------------------------------------
# CONFIGURACIÓN GENERAL
# ----------------------------------------------------------------------
# MODO de ejecución:
#   - "LOCAL": para pruebas en Jupyter / entorno de desarrollo.
#   - "PROD" : para ejecución en Airflow / servidor.
MODO = "LOCAL"  # Cambiar a "PROD" en el servidor.

# Conexión a base de datos (predef_conn usado por sqlConn)
DB_CONN = "AT_CMDTS"  # Cambiar si en LOCAL querés otra BD.


if MODO == "LOCAL":
    # Ejemplo para pruebas: apuntar a una carpeta de una fecha específica.
    #
    # Si tus consolidados están en:
    #   /home/leonardd/Plexus/PROSEGUR/CONSOLIDADO/2025-11-11
    # podés setear:
    #   CONSOLIDADO_BASE = r"/home/leonardd/Plexus/PROSEGUR/CONSOLIDADO/2025-11-11"
    #   USE_DATE_SUBFOLDER = False
    #
    # Ajustá estas dos variables según necesites.
    CONSOLIDADO_BASE = r"/home/leonardd/Plexus/PROSEGUR/CONSOLIDADO/2025-11-11"
    USE_DATE_SUBFOLDER = False

elif MODO == "PROD":
    # En producción normalmente tenés:
    #   //nfs_airflow_py/.../Transportadoras/Prosegur/CONSOLIDADO/AAAA-MM-DD
    ROOT = r"//nfs_airflow_py/cmdat/ea-saa-datos/Transportadoras/Prosegur"
    CONSOLIDADO_BASE = os.path.join(ROOT, "CONSOLIDADO")

    # En PROD se usa subcarpeta por fecha (YYYY-MM-DD)
    USE_DATE_SUBFOLDER = True

else:
    raise ValueError(f"MODO desconocido: {MODO}")


def ruta_consolidado_fecha(fecha: str) -> str:
    """
    Devuelve la ruta a la carpeta de consolidados para una fecha dada.

    - Si USE_DATE_SUBFOLDER es True: CONSOLIDADO_BASE/fecha
    - Si USE_DATE_SUBFOLDER es False: CONSOLIDADO_BASE (ignora fecha)
    """
    if USE_DATE_SUBFOLDER:
        return os.path.join(CONSOLIDADO_BASE, fecha)
    return CONSOLIDADO_BASE


# ----------------------------------------------------------------------
# LOG / UTILIDADES DE CORREO
# ----------------------------------------------------------------------

def buscar_log(fecha: str) -> Optional[str]:
    """
    Localiza PROSEGUR.txt (o variantes de mayúsculas/minúsculas) en la carpeta
    de consolidados de esa fecha.
    """
    carpeta = ruta_consolidado_fecha(fecha)
    posibles_nombres = ["PROSEGUR.txt", "Prosegur.txt", "PROSEGUR_LOG.txt"]
    for nombre in posibles_nombres:
        path = os.path.join(carpeta, nombre)
        if os.path.isfile(path):
            return path
    return None


def enviar_email_error(fecha_hoy: str, detalle: str, ruta_log: Optional[str] = None) -> None:
    """
    Envía un correo de error del proceso PROSEGUR.

    Si se pasa ruta_log y existe, adjunta el PROSEGUR.txt.
    """
    asunto = f"PROSEGUR - Error en el proceso ({fecha_hoy})"
    mensaje = (
        "Se produjo un error durante el proceso de PROSEGUR.\n\n"
        f"Fecha de proceso: {fecha_hoy}\n"
        f"Detalle: {detalle}"
    )

    destinatarios = [
        # Ajustar destinatarios reales:
        "Leonardo Doldan <correo1jemplo@ejemplo.com.py>",
        "Carlos Rodriguez <correo2jemplo@ejemplo.com.py>",
    ]

    if ruta_log is not None and os.path.isfile(ruta_log):
        try:
            email.enviarEmailAdjunto(
                destinatario=destinatarios,
                asunto=asunto,
                mensaje=mensaje,
                ruta_adjunto=ruta_log,
                nombre_adjunto=os.path.basename(ruta_log),
            )
        except Exception as e:
            print(f"[WARN] No se pudo enviar correo de error con adjunto: {e}")
    else:
        try:
            email.enviarEmail(
                destinatario=destinatarios,
                asunto=asunto,
                mensaje=mensaje,
            )
        except Exception as e:
            print(f"[WARN] No se pudo enviar correo de error sin adjunto: {e}")


def enviar_email_exito(fecha_hoy: str, ruta_log: Optional[str] = None) -> None:
    """
    Envía un correo indicando que el proceso finalizó correctamente.

    Si está disponible PROSEGUR.txt, se adjunta al correo.
    """
    asunto = f"PROSEGUR - Proceso de consolidado y carga OK ({fecha_hoy})"
    mensaje = (
        "Proceso PROSEGUR finalizado correctamente.\n\n"
        f"Fecha de proceso: {fecha_hoy}\n"
        "Se generaron los archivos consolidados y se poblaron las tablas en AT_CMDTS sin errores."
    )

    destinatarios = [
        # Ajustar destinatarios reales:
        "Leonardo Doldan <correo1jemplo@ejemplo.com.py>",
        "Carlos Rodriguez <correo2jemplo@ejemplo.com.py>",
    ]

    if ruta_log is not None and os.path.isfile(ruta_log):
        try:
            email.enviarEmailAdjunto(
                destinatario=destinatarios,
                asunto=asunto,
                mensaje=mensaje,
                ruta_adjunto=ruta_log,
                nombre_adjunto=os.path.basename(ruta_log),
            )
        except Exception as e:
            print(f"[WARN] No se pudo enviar correo de éxito con adjunto: {e}")
    else:
        try:
            email.enviarEmail(
                destinatario=destinatarios,
                asunto=asunto,
                mensaje=mensaje,
            )
        except Exception as e:
            print(f"[WARN] No se pudo enviar correo de éxito sin adjunto: {e}")


# ----------------------------------------------------------------------
# CHEQUEO DE ARCHIVOS
# ----------------------------------------------------------------------

def checkea_archivos_creados(fecha: str) -> Tuple[int, List[str]]:
    """
    Verifica que existan todos los archivos consolidados PROSEGUR esperados.

    Devuelve (cantidad_ok, lista_faltantes).
    Si la carpeta no existe, devuelve (-1, ["CARPETA_NO_EXISTE"]).
    """
    carpeta = ruta_consolidado_fecha(fecha)
    print(f"Carpeta de consolidados a revisar: {carpeta}")

    if not os.path.isdir(carpeta):
        print("NO EXISTE LA CARPETA DE CONSOLIDADOS PARA ESA FECHA")
        return -1, ["CARPETA_NO_EXISTE"]

    esperados = {
        "EC_BCO": "PROSEGUR_EFECTBANCO.csv",
        "EC_ATM": "PROSEGUR_EFECTATM.csv",
        "INV_ATM": "PROSEGUR_INVENTARIO_ATM.csv",
        "INV_BCO": "PROSEGUR_INVENTARIO_BCO.csv",
        "BULTOS_ATM": "PROSEGUR_BULTOSATM.csv",
        "BULTOS_BCO": "PROSEGUR_BULTOSBANCO.csv",
    }

    archivos_en_carpeta = set(os.listdir(carpeta))
    ok = 0
    faltantes: List[str] = []

    for clave, nombre in esperados.items():
        if nombre in archivos_en_carpeta:
            print(f"ARCHIVO {clave} ({nombre}) CREADO")
            ok += 1
        else:
            print(f"FALTA ARCHIVO {clave} ({nombre})")
            faltantes.append(nombre)

    if ok == len(esperados):
        print("SE TIENEN TODOS LOS ARCHIVOS CREADOS EN LA CARPETA CONSOLIDADO")
    else:
        print(
            f"NO SE CREARON TODOS LOS ARCHIVOS. ESPERADOS={len(esperados)}, ENCONTRADOS={ok}"
        )

    return ok, faltantes


def _leer_csv_consolidado(fecha: str, nombre_archivo: str) -> Tuple[Optional[pd.DataFrame], Optional[str]]:
    """
    Lee un CSV consolidado específico para la fecha dada.

    Devuelve (df, error):
      - df != None y error None si todo ok.
      - df None y error con mensaje si hubo problema (lectura o vacío).
    """
    carpeta = ruta_consolidado_fecha(fecha)
    path = os.path.join(carpeta, nombre_archivo)

    try:
        df = pd.read_csv(path, sep=";", encoding="utf-8-sig")
    except Exception as e:
        msg = f"NO SE PUDO LEER ARCHIVO {nombre_archivo}: {e}"
        print(msg)
        return None, msg

    if df.empty:
        msg = f"DATAFRAME DE {nombre_archivo} VACÍO"
        print(msg)
        return None, msg

    print(f"DATAFRAME {nombre_archivo} TRAE DATOS: {df.shape}")
    return df, None


# ----------------------------------------------------------------------
# CARGA A TABLAS (AT_CMDTS u otra BD definida en DB_CONN)
# ----------------------------------------------------------------------

def _agrega_fecha_creacion(df: pd.DataFrame) -> pd.DataFrame:
    """
    Elimina FECHA_CREACION previa (si existe) y agrega la columna nueva.
    """
    if "FECHA_CREACION" in df.columns:
        df = df.drop(columns=["FECHA_CREACION"])
    df["FECHA_CREACION"] = pd.to_datetime(datetime.now())
    return df


def _crea_conexion(nombre_contexto: str) -> sqlConn:
    """
    Crea la conexión usando DB_CONN.

    nombre_contexto sólo se usa para mensajes de error.
    """
    try:
        return sqlConn(predef_conn=DB_CONN, agendado=False)
    except Exception as e:
        raise RuntimeError(
            f"NO SE PUDO CREAR CONEXIÓN A {DB_CONN} PARA {nombre_contexto}: {e}"
        )


# ---- EFECTIVO BANCO ---------------------------------------------------

def puebla_tabla_ec_banco(fecha: str) -> None:
    """
    Pobla la tabla PLXS_EC_BCO_PROSEGUR_2025 desde PROSEGUR_EFECTBANCO.csv

    Esquema esperado:
      FECHA_RECIBO, SUCURSAL, RECIBO, BULTOS, IMPORTE, MONEDA,
      ING_EGR, CLASIFICACION, FECHA_ARCHIVO, MOTIVO_MOVIMIENTO,
      AGENCIA, SALDO_ANTERIOR, FECHA_CREACION
    """
    nombre_archivo = "PROSEGUR_EFECTBANCO.csv"
    df, err = _leer_csv_consolidado(fecha, nombre_archivo)
    if df is None:
        raise ValueError(err or f"Error desconocido al leer {nombre_archivo}")

    # En el CSV consolidado la fecha de operación suele venir como FECHA
    if "FECHA" in df.columns and "FECHA_RECIBO" not in df.columns:
        df = df.rename(columns={"FECHA": "FECHA_RECIBO"})

    # Conversión de fechas
    try:
        if "FECHA_RECIBO" in df.columns:
            df["FECHA_RECIBO"] = pd.to_datetime(
                df["FECHA_RECIBO"], format="%d/%m/%Y", errors="coerce"
            ).dt.date
        if "FECHA_ARCHIVO" in df.columns:
            df["FECHA_ARCHIVO"] = pd.to_datetime(
                df["FECHA_ARCHIVO"], format="%d/%m/%Y", errors="coerce"
            ).dt.date
    except Exception as e:
        print(f"ADVERTENCIA: No se pudo convertir fechas en EC_BANCO PROSEGUR: {e}")

    # Agregamos FECHA_CREACION y reordenamos columnas al esquema final
    df = _agrega_fecha_creacion(df)

    cols_ec_bco = [
        "FECHA_RECIBO",
        "SUCURSAL",
        "RECIBO",
        "BULTOS",
        "IMPORTE",
        "MONEDA",
        "ING_EGR",
        "CLASIFICACION",
        "FECHA_ARCHIVO",
        "MOTIVO_MOVIMIENTO",
        "AGENCIA",
        "SALDO_ANTERIOR",
        "FECHA_CREACION",
    ]
    for col in cols_ec_bco:
        if col not in df.columns:
            df[col] = None
    df = df[cols_ec_bco]

    conn_ = _crea_conexion("EC_BANCO_PROSEGUR")
    try:
        conn_.crea_tabla(df, "PLXS_EC_BCO_PROSEGUR_2025", if_exists="append")
        conn_.desconecta()
        print("TABLA EC_BANCO PROSEGUR POBLADA")
    except Exception as e:
        conn_.desconecta()
        raise RuntimeError(
            f"PROBLEMA CON LA CREACIÓN/INSERCIÓN EN TABLA PLXS_EC_BCO_PROSEGUR_2025: {e}"
        )


# ---- EFECTIVO ATM -----------------------------------------------------

def puebla_tabla_ec_atm(fecha: str) -> None:
    """
    Pobla la tabla PLXS_PROSEGUR_EFECTATM desde PROSEGUR_EFECTATM.csv

    Esquema esperado:
      FECHA_RECIBO, SUCURSAL, RECIBO, BULTOS, GUARANIES, DOLARES,
      ING_EGR, CLASIFICACION, FECHA_ARCHIVO, MOTIVO_MOVIMIENTO,
      AGENCIA, SALDO_ANTERIOR_PYG, SALDO_ANTERIOR_USD, FECHA_CREACION
    """
    nombre_archivo = "PROSEGUR_EFECTATM.csv"
    df, err = _leer_csv_consolidado(fecha, nombre_archivo)
    if df is None:
        raise ValueError(err or f"Error desconocido al leer {nombre_archivo}")

    # FECHA (operación) → FECHA_RECIBO
    if "FECHA" in df.columns and "FECHA_RECIBO" not in df.columns:
        df = df.rename(columns={"FECHA": "FECHA_RECIBO"})

    try:
        if "FECHA_RECIBO" in df.columns:
            df["FECHA_RECIBO"] = pd.to_datetime(
                df["FECHA_RECIBO"], format="%d/%m/%Y", errors="coerce"
            ).dt.date
        if "FECHA_ARCHIVO" in df.columns:
            df["FECHA_ARCHIVO"] = pd.to_datetime(
                df["FECHA_ARCHIVO"], format="%d/%m/%Y", errors="coerce"
            ).dt.date
    except Exception as e:
        print(f"ADVERTENCIA: No se pudo convertir fechas en EC_ATM PROSEGUR: {e}")

    df = _agrega_fecha_creacion(df)

    cols_ec_atm = [
        "FECHA_RECIBO",
        "SUCURSAL",
        "RECIBO",
        "BULTOS",
        "GUARANIES",
        "DOLARES",
        "ING_EGR",
        "CLASIFICACION",
        "FECHA_ARCHIVO",
        "MOTIVO_MOVIMIENTO",
        "AGENCIA",
        "SALDO_ANTERIOR_PYG",
        "SALDO_ANTERIOR_USD",
        "FECHA_CREACION",
    ]
    for col in cols_ec_atm:
        if col not in df.columns:
            df[col] = None
    df = df[cols_ec_atm]

    conn_ = _crea_conexion("EC_ATM_PROSEGUR")
    try:
        conn_.crea_tabla(df, "PLXS_PROSEGUR_EFECTATM", if_exists="append")
        conn_.desconecta()
        print("TABLA EC_ATM PROSEGUR POBLADA")
    except Exception as e:
        conn_.desconecta()
        raise RuntimeError(
            f"PROBLEMA CON LA CREACIÓN/INSERCIÓN EN TABLA PLXS_PROSEGUR_EFECTATM: {e}"
        )


# ---- INVENTARIO BANCO -------------------------------------------------

def puebla_tabla_inv_banco(fecha: str) -> None:
    """
    Pobla la tabla PLXS_PROSEGUR_INVENTARIO_BANCO desde PROSEGUR_INVENTARIO_BCO.csv

    Esquema esperado:
      FECHA_INVENTARIO, DIVISA, AGENCIA, AGRUPACION_EFECTIVO, TIPO_VALOR,
      DENOMINACION, DEPOSITO, CJE_DEP, CANJE, MONEDA, IMPORTE_TOTAL,
      FECHA_CREACION
    """
    nombre_archivo = "PROSEGUR_INVENTARIO_BCO.csv"
    df, err = _leer_csv_consolidado(fecha, nombre_archivo)
    if df is None:
        raise ValueError(err or f"Error desconocido al leer {nombre_archivo}")

    try:
        if "FECHA_INVENTARIO" in df.columns:
            df["FECHA_INVENTARIO"] = pd.to_datetime(
                df["FECHA_INVENTARIO"], format="%d/%m/%Y", errors="coerce"
            ).dt.date
    except Exception as e:
        print(
            f"ADVERTENCIA: No se pudo convertir FECHA_INVENTARIO en INV_BANCO PROSEGUR: {e}"
        )

    df = _agrega_fecha_creacion(df)

    cols_inv_bco = [
        "FECHA_INVENTARIO",
        "DIVISA",
        "AGENCIA",
        "AGRUPACION_EFECTIVO",
        "TIPO_VALOR",
        "DENOMINACION",
        "DEPOSITO",
        "CJE_DEP",
        "CANJE",
        "MONEDA",
        "IMPORTE_TOTAL",
        "FECHA_CREACION",
    ]
    for col in cols_inv_bco:
        if col not in df.columns:
            df[col] = None
    df = df[cols_inv_bco]

    conn_ = _crea_conexion("INV_BANCO_PROSEGUR")
    try:
        conn_.crea_tabla(df, "PLXS_PROSEGUR_INVENTARIO_BANCO", if_exists="append")
        conn_.desconecta()
        print("TABLA INVENTARIO BANCO PROSEGUR POBLADA")
    except Exception as e:
        conn_.desconecta()
        raise RuntimeError(
            f"PROBLEMA CON LA CREACIÓN/INSERCIÓN EN TABLA PLXS_PROSEGUR_INVENTARIO_BANCO: {e}"
        )


# ---- INVENTARIO ATM ---------------------------------------------------

def puebla_tabla_inv_atm(fecha: str) -> None:
    """
    Pobla la tabla PLXS_PROSEGUR_INVENTARIO_ATM desde PROSEGUR_INVENTARIO_ATM.csv

    Esquema esperado:
      FECHA_INVENTARIO, DIVISA, AGENCIA, AGRUPACION_EFECTIVO, TIPO_VALOR,
      DENOMINACION, DEPOSITO, CJE_DEP, CANJE, MONEDA, IMPORTE_TOTAL,
      FECHA_CREACION
    """
    nombre_archivo = "PROSEGUR_INVENTARIO_ATM.csv"
    df, err = _leer_csv_consolidado(fecha, nombre_archivo)
    if df is None:
        raise ValueError(err or f"Error desconocido al leer {nombre_archivo}")

    try:
        if "FECHA_INVENTARIO" in df.columns:
            df["FECHA_INVENTARIO"] = pd.to_datetime(
                df["FECHA_INVENTARIO"], format="%d/%m/%Y", errors="coerce"
            ).dt.date
    except Exception as e:
        print(
            f"ADVERTENCIA: No se pudo convertir FECHA_INVENTARIO en INV_ATM PROSEGUR: {e}"
        )

    df = _agrega_fecha_creacion(df)

    cols_inv_atm = [
        "FECHA_INVENTARIO",
        "DIVISA",
        "AGENCIA",
        "AGRUPACION_EFECTIVO",
        "TIPO_VALOR",
        "DENOMINACION",
        "DEPOSITO",
        "CJE_DEP",
        "CANJE",
        "MONEDA",
        "IMPORTE_TOTAL",
        "FECHA_CREACION",
    ]
    for col in cols_inv_atm:
        if col not in df.columns:
            df[col] = None
    df = df[cols_inv_atm]

    conn_ = _crea_conexion("INV_ATM_PROSEGUR")
    try:
        conn_.crea_tabla(df, "PLXS_PROSEGUR_INVENTARIO_ATM", if_exists="append")
        conn_.desconecta()
        print("TABLA INVENTARIO ATM PROSEGUR POBLADA")
    except Exception as e:
        conn_.desconecta()
        raise RuntimeError(
            f"PROBLEMA CON LA CREACIÓN/INSERCIÓN EN TABLA PLXS_PROSEGUR_INVENTARIO_ATM: {e}"
        )


# ---- BULTOS ATM -------------------------------------------------------

def puebla_tabla_bultos_atm(fecha: str) -> None:
    """
    Pobla la tabla PLXS_PROSEGUR_BULTOSATM desde PROSEGUR_BULTOSATM.csv

    Esquema esperado:
      FECHA_RECIBO, SUCURSAL, RECIBO, BULTOS, MONEDA, IMPORTE,
      ING_EGR, CLASIFICACION, FECHA_ARCHIVO, MOTIVO_MOVIMIENTO,
      AGENCIA, SALDO_ANTERIOR, FECHA_CREACION
    """
    nombre_archivo = "PROSEGUR_BULTOSATM.csv"
    df, err = _leer_csv_consolidado(fecha, nombre_archivo)
    if df is None:
        raise ValueError(err or f"Error desconocido al leer {nombre_archivo}")

    if "FECHA" in df.columns and "FECHA_RECIBO" not in df.columns:
        df = df.rename(columns={"FECHA": "FECHA_RECIBO"})

    try:
        if "FECHA_RECIBO" in df.columns:
            df["FECHA_RECIBO"] = pd.to_datetime(
                df["FECHA_RECIBO"], format="%d/%m/%Y", errors="coerce"
            ).dt.date
        if "FECHA_ARCHIVO" in df.columns:
            df["FECHA_ARCHIVO"] = pd.to_datetime(
                df["FECHA_ARCHIVO"], format="%d/%m/%Y", errors="coerce"
            ).dt.date
    except Exception as e:
        print(f"ADVERTENCIA: No se pudo convertir fechas en BULTOS_ATM PROSEGUR: {e}")

    df = _agrega_fecha_creacion(df)

    cols_bultos_atm = [
        "FECHA_RECIBO",
        "SUCURSAL",
        "RECIBO",
        "BULTOS",
        "MONEDA",
        "IMPORTE",
        "ING_EGR",
        "CLASIFICACION",
        "FECHA_ARCHIVO",
        "MOTIVO_MOVIMIENTO",
        "AGENCIA",
        "SALDO_ANTERIOR",
        "FECHA_CREACION",
    ]
    for col in cols_bultos_atm:
        if col not in df.columns:
            df[col] = None
    df = df[cols_bultos_atm]

    conn_ = _crea_conexion("BULTOS_ATM_PROSEGUR")
    try:
        conn_.crea_tabla(df, "PLXS_PROSEGUR_BULTOSATM", if_exists="append")
        conn_.desconecta()
        print("TABLA BULTOS ATM PROSEGUR POBLADA")
    except Exception as e:
        conn_.desconecta()
        raise RuntimeError(
            f"PROBLEMA CON LA CREACIÓN/INSERCIÓN EN TABLA PLXS_PROSEGUR_BULTOSATM: {e}"
        )


# ---- BULTOS BANCO -----------------------------------------------------

def puebla_tabla_bultos_banco(fecha: str) -> None:
    """
    Pobla la tabla PLXS_PROSEGUR_BULTOSBANCO desde PROSEGUR_BULTOSBANCO.csv

    Esquema esperado:
      FECHA_RECIBO, SUCURSAL, RECIBO, BULTOS, MONEDA, IMPORTE,
      ING_EGR, CLASIFICACION, FECHA_ARCHIVO, MOTIVO_MOVIMIENTO,
      AGENCIA, SALDO_ANTERIOR, FECHA_CREACION
    """
    nombre_archivo = "PROSEGUR_BULTOSBANCO.csv"
    df, err = _leer_csv_consolidado(fecha, nombre_archivo)
    if df is None:
        raise ValueError(err or f"Error desconocido al leer {nombre_archivo}")

    if "FECHA" in df.columns and "FECHA_RECIBO" not in df.columns:
        df = df.rename(columns={"FECHA": "FECHA_RECIBO"})

    try:
        if "FECHA_RECIBO" in df.columns:
            df["FECHA_RECIBO"] = pd.to_datetime(
                df["FECHA_RECIBO"], format="%d/%m/%Y", errors="coerce"
            ).dt.date
        if "FECHA_ARCHIVO" in df.columns:
            df["FECHA_ARCHIVO"] = pd.to_datetime(
                df["FECHA_ARCHIVO"], format="%d/%m/%Y", errors="coerce"
            ).dt.date
    except Exception as e:
        print(f"ADVERTENCIA: No se pudo convertir fechas en BULTOS_BANCO PROSEGUR: {e}")

    df = _agrega_fecha_creacion(df)

    cols_bultos_bco = [
        "FECHA_RECIBO",
        "SUCURSAL",
        "RECIBO",
        "BULTOS",
        "MONEDA",
        "IMPORTE",
        "ING_EGR",
        "CLASIFICACION",
        "FECHA_ARCHIVO",
        "MOTIVO_MOVIMIENTO",
        "AGENCIA",
        "SALDO_ANTERIOR",
        "FECHA_CREACION",
    ]
    for col in cols_bultos_bco:
        if col not in df.columns:
            df[col] = None
    df = df[cols_bultos_bco]

    conn_ = _crea_conexion("BULTOS_BANCO_PROSEGUR")
    try:
        conn_.crea_tabla(df, "PLXS_PROSEGUR_BULTOSBANCO", if_exists="append")
        conn_.desconecta()
        print("TABLA BULTOS BANCO PROSEGUR POBLADA")
    except Exception as e:
        conn_.desconecta()
        raise RuntimeError(
            f"PROBLEMA CON LA CREACIÓN/INSERCIÓN EN TABLA PLXS_PROSEGUR_BULTOSBANCO: {e}"
        )


# ----------------------------------------------------------------------
# ORQUESTADOR
# ----------------------------------------------------------------------

def run(fecha: Optional[str] = None) -> None:
    """
    Orquesta la subida de tablas para la fecha indicada.

    Maneja:
      - Faltan archivos consolidados.
      - CSV vacío / error de lectura.
      - Errores de base de datos.
    Y envía correos según el resultado.
    """
    if fecha is None:
        fecha = datetime.now().strftime("%Y-%m-%d")

    print(f"FECHA: {fecha}")

    ruta_log = buscar_log(fecha)
    cant_archivos, faltantes = checkea_archivos_creados(fecha)
    print(f"CANTIDAD DE ARCHIVOS CREADOS: {cant_archivos}")

    # Validación de existencia de todos los archivos
    if cant_archivos != 6:
        detalle = (
            "Archivos necesarios para poblar las tablas PROSEGUR no fueron creados "
            f"o están incompletos. Faltantes: {', '.join(faltantes) if faltantes else 'DESCONOCIDO'}"
        )
        enviar_email_error(fecha, detalle, ruta_log)
        return

    # Proceso de carga propiamente dicho
    try:
        puebla_tabla_ec_banco(fecha)
        puebla_tabla_ec_atm(fecha)
        puebla_tabla_inv_atm(fecha)
        puebla_tabla_inv_banco(fecha)
        puebla_tabla_bultos_atm(fecha)
        puebla_tabla_bultos_banco(fecha)
    except ValueError as ve:
        detalle = f"Error de archivo/DF en el proceso PROSEGUR: {ve}"
        enviar_email_error(fecha, detalle, ruta_log)
        return
    except RuntimeError as re_err:
        detalle = f"Error de base de datos en el proceso PROSEGUR: {re_err}"
        enviar_email_error(fecha, detalle, ruta_log)
        return
    except Exception as e:
        detalle = f"Error inesperado en el proceso PROSEGUR: {e}"
        enviar_email_error(fecha, detalle, ruta_log)
        return

    print("FINALIZÓ PROCESO DE SUBIDA A TABLAS PROSEGUR CON ÉXITO")
    enviar_email_exito(fecha, ruta_log)


if __name__ == "__main__":
    run()
