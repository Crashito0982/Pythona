import os
from datetime import datetime
from typing import Dict, List

import pandas as pd
from pandas.api.types import is_numeric_dtype
from sqlConn import sqlConn
import re

# ======================================================================
# CONFIGURACI√ìN
# ======================================================================
# MODO:
#   "AT"    -> pruebas en Jupyter apuntando a AT_CMDTS
#   "ODSPE" -> producci√≥n en ODSPE / Airflow
MODO = "AT"  # üîÅ cambiar a "ODSPE" cuando pases a producci√≥n

if MODO == "AT":
    # Ruta local para pruebas en Jupyter
    EXCEL_PATH = r"/home/leonardd/Plexus/BRITIMP/BaseParametrica_modelo_agencias.xlsx"
    PREDEF_CONN = "AT_CMDTS"
else:
    # Ruta en el ambiente de Airflow / ODSPE
    EXCEL_PATH = r"//nfs_airflow_py/cmdat/ea-saa-datos/Transportadoras/Britimp/BaseParametrica_modelo_agencias.xlsx"
    PREDEF_CONN = "ODSPE"  # ajustar al nombre real de la conexi√≥n en sqlConn


# Configuraci√≥n por hoja
SHEET_CONFIG: Dict[str, Dict] = {
    "Datos": {
        "table": "PLXS_BASE_PARAMETRICA_MODELO_AGENCIAS_DATOS",
        # Nombres tal como vienen en el Excel
        "numeric_cols": ["Milaje", "Precio Km", "Kms", "Costo KM"],
        # Redondeos (decimales) por columna (Excel)
        "rounding": {
            "Milaje": 2,
            "Precio Km": 0,
            "Kms": 0,
            "Costo KM": 0,
        },
        # Mapeo Excel -> columna SQL
        "column_map": {
            "Agencias_Transportadora": "AGENCIAS_TRANSPORTADORAS",
            "Agencias_Transportadoras": "AGENCIAS_TRANSPORTADORAS",  # por si viene as√≠
            "Agencia": "AGENCIA",
            "Proveedor": "PROVEEDOR",
            "Milaje": "MILAJE",
            "Precio Km": "PRECIO_KM",
            "Kms": "KMS",
            "Costo KM": "COSTO_KM",
        },
    },
    "Seguro": {
        "table": "PLXS_BASE_PARAMETRICA_MODELO_AGENCIAS_SEGURO",
        "numeric_cols": ["Cod. Ag.", "Seguro Caja"],
        "rounding": {},  # sin redondeo especial; solo conversion a num√©rico
        "column_map": {
            "AGENCIA_BASE": "AGENCIA_BASE",
            "Cod. Ag.": "COD_AG",
            "Agencia": "AGENCIA",
            "Seguro Caja": "SEGURO_CAJA",
        },
    },
    "Parametros": {
        "table": "PLXS_BASE_PARAMETRICA_MODELO_AGENCIAS_PARAMETROS",
        "numeric_cols": ["Valor"],
        "rounding": {
            "Valor": 6,
        },
        "column_map": {
            "Parametros": "PARAMETROS",
            "Valor": "VALOR",
        },
    },
}


# ======================================================================
# HELPERS
# ======================================================================
def clean_and_round_numeric(
    df: pd.DataFrame,
    sheet_name: str,
    numeric_cols: List[str],
    rounding: Dict[str, int],
) -> pd.DataFrame:
    """
    Limpia y redondea las columnas num√©ricas seg√∫n la configuraci√≥n de la hoja.

    - Limpieza:
        * Quita separadores de miles "."
        * Reemplaza coma decimal "," por "."
        * Convierte a numeric con errors='coerce' -> valores no num√©ricos -> NaN (NULL)

    - Redondeo:
        * Aplica los decimales definidos en 'rounding' para cada columna.
    """
    for col in numeric_cols:
        if col not in df.columns:
            print(f"[WARN] Columna num√©rica '{col}' no encontrada en hoja '{sheet_name}'.")
            continue

        serie = df[col]

        # Si ya es num√©rico, lo tomamos tal cual; si no, limpiamos texto
        if not is_numeric_dtype(serie):
            serie = serie.astype(str).str.strip()
            serie = serie.replace({"": None, "-": None})
            serie = serie.str.replace(".", "", regex=False)
            serie = serie.str.replace(",", ".", regex=False)
            serie = pd.to_numeric(serie, errors="coerce")

        # Aplicar redondeo si est√° configurado
        decimales = rounding.get(col)
        if decimales is not None:
            serie = serie.round(decimales)

        df[col] = serie

    return df


def construir_dataframe_final(
    df_raw: pd.DataFrame,
    sheet_name: str,
    cfg: Dict,
) -> pd.DataFrame:
    """
    A partir del df original le√≠do del Excel y la config de la hoja,
    construye un DataFrame con los nombres de columnas de destino
    y agrega FECHA_CREACION al final.
    """
    numeric_cols = cfg.get("numeric_cols", [])
    rounding = cfg.get("rounding", {})
    column_map = cfg.get("column_map", {})

    # 1) Limpiar y redondear columnas num√©ricas
    df = df_raw.copy()
    df = clean_and_round_numeric(df, sheet_name, numeric_cols, rounding)

    # 2) Construir DataFrame con columnas de destino en el orden que quer√©s
    cols_destino = list(column_map.values())
    data = {}

    for col_origen, col_destino in column_map.items():
        if col_origen in df.columns:
            data[col_destino] = df[col_origen]
        else:
            print(f"[WARN] Columna origen '{col_origen}' no encontrada en hoja '{sheet_name}'. Se llena con NULL.")
            data[col_destino] = None

    df_final = pd.DataFrame(data, index=df.index)

    # 3) Agregar FECHA_CREACION al final
    df_final["FECHA_CREACION"] = datetime.now()

    return df_final


def truncar_tabla(conn_, table_name: str) -> None:
    """
    Ejecuta TRUNCATE TABLE usando el atributo 'cnxn' de sqlConn.
    (En borra_tabla ya usan self.cnxn.execute, as√≠ que asumimos que existe.)
    """
    sql = f"TRUNCATE TABLE {table_name}"
    print(f"Truncando tabla '{table_name}'...")
    try:
        conn_.cnxn.execute(sql)
        # Si tu conexi√≥n requiere commit expl√≠cito:
        try:
            conn_.cnxn.commit()
        except Exception:
            # Si no soporta commit o est√° en autocommit, ignoramos
            pass
    except Exception as ex:
        print(f"[ERROR] No se pudo truncar la tabla {table_name}: {ex}")
        raise


def cargar_hoja_y_poblar_tabla(sheet_name: str, cfg: Dict) -> None:
    """
    Lee la hoja 'sheet_name', arma el DataFrame final con los nombres correctos,
    trunca la tabla destino y hace INSERT (append) de los datos.
    """
    table_name = cfg["table"]
    print(f"\n=== Procesando hoja '{sheet_name}' -> tabla '{table_name}' ===")

    # Leer hoja del Excel
    try:
        df_raw = pd.read_excel(EXCEL_PATH, sheet_name=sheet_name)
    except Exception as e:
        raise RuntimeError(f"No se pudo leer la hoja '{sheet_name}' del Excel: {e}")

    if df_raw.empty:
        raise ValueError(f"La hoja '{sheet_name}' est√° vac√≠a; no se poblar√° la tabla '{table_name}'.")

    # Construir DataFrame final con nombres correctos + FECHA_CREACION
    df_final = construir_dataframe_final(df_raw, sheet_name, cfg)
    print(f"DataFrame final para '{table_name}' listo. Forma: {df_final.shape}")

    # Conexi√≥n
    print(f"Conectando a la BD con predef_conn='{PREDEF_CONN}'...")
    conn_ = sqlConn(predef_conn=PREDEF_CONN, agendado=False)

    try:
        # 1) TRUNCATE TABLE
        truncar_tabla(conn_, table_name)

        # 2) INSERT (append)
        conn_.crea_tabla(df_final, table_name, if_exists="append")
        print(f"Tabla '{table_name}' poblada con {len(df_final)} registros (TRUNCATE + INSERT).")

    finally:
        try:
            conn_.desconecta()
        except Exception:
            pass


# ======================================================================
# ORQUESTADOR
# ======================================================================
def run() -> None:
    """
    Recorre las 3 hojas de BaseParametrica_modelo_agencias.xlsx
    y para cada una:
      - Lee el Excel
      - Limpia y redondea num√©ricos
      - Mapea columnas al nombre de la tabla
      - Trunca la tabla
      - Inserta los datos
    """
    print("=" * 70)
    print(f"INICIO PROCESO BASE PARAMETRICA - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f"MODO: {MODO}")
    print(f"Archivo origen: {EXCEL_PATH}")
    print("=" * 70)

    if not os.path.isfile(EXCEL_PATH):
        raise FileNotFoundError(f"No se encontr√≥ el archivo Excel en la ruta: {EXCEL_PATH}")

    for sheet_name, cfg in SHEET_CONFIG.items():
        cargar_hoja_y_poblar_tabla(sheet_name, cfg)

    print("\nPROCESO BASE PARAMETRICA FINALIZADO CORRECTAMENTE.")
    print("=" * 70)


if __name__ == "__main__":
    run()
