def post_process_dataframes(data_dict: Dict[str, pd.DataFrame]) -> Dict[str, pd.DataFrame]:
    """
    Aplica limpiezas finales a los dataframes: renombra, formatea y elimina columnas.
    - Elimina ARCHIVO_ORIGEN si existe.
    """
    processed_dict: Dict[str, pd.DataFrame] = {}

    for tipo, df in data_dict.items():
        if df.empty:
            continue

        df_copy = df.copy()

        # Eliminar ARCHIVO_ORIGEN
        if "ARCHIVO_ORIGEN" in df_copy.columns:
            df_copy = df_copy.drop(columns=["ARCHIVO_ORIGEN"])

        # Procesar archivos de Estado de Cuenta (EC)
        if tipo.startswith("EC_"):
            # FECHA_OPERACION -> FECHA_RECIBO
            if "FECHA_OPERACION" in df_copy.columns:
                df_copy = df_copy.rename(columns={"FECHA_OPERACION": "FECHA_RECIBO"})

            # Formatear números a enteros (Int64 para admitir nulos)
            for col in ["MONTO", "IMPORTE", "BULTOS"]:
                if col in df_copy.columns:
                    df_copy[col] = (
                        pd.to_numeric(df_copy[col], errors="coerce")
                        .astype("Int64")
                    )

        # Procesar archivos de Inventario (INV)
        if tipo.startswith("INV_"):
            # Mover CJE_DEP a CALIDAD_CD si existe (del parser XLSX)
            if "CJE_DEP" in df_copy.columns:
                # Llenar CALIDAD_CD con CJE_DEP solo si CALIDAD_CD está vacío
                if "CALIDAD_CD" not in df_copy:
                    df_copy["CALIDAD_CD"] = None
                df_copy["CALIDAD_CD"] = df_copy["CALIDAD_CD"].fillna(df_copy["CJE_DEP"])
                df_copy = df_copy.drop(columns=["CJE_DEP"])

            # Formatear números a enteros
            for col in [
                "DENOMINACION",
                "CALIDAD_DEPOSITO",
                "CALIDAD_CD",
                "CALIDAD_CANJE",
                "MONEDA",
                "IMPORTE_TOTAL",
            ]:
                if col in df_copy.columns:
                    df_copy[col] = (
                        pd.to_numeric(df_copy[col], errors="coerce")
                        .astype("Int64")
                    )

        # Normalización específica para EC_ATM y BULTOS_ATM:
        # MONTO -> IMPORTE para que coincida con la estructura de las tablas finales
        if tipo in ("EC_EFECT_ATM", "EC_BULTO_ATM"):
            if "MONTO" in df_copy.columns and "IMPORTE" not in df_copy.columns:
                df_copy = df_copy.rename(columns={"MONTO": "IMPORTE"})

        # Reordenar y seleccionar columnas finales según FINAL_COLUMNS
        if tipo in FINAL_COLUMNS:
            final_cols = [col for col in FINAL_COLUMNS[tipo] if col in df_copy.columns]
            processed_dict[tipo] = df_copy[final_cols]
        else:
            processed_dict[tipo] = df_copy

    return processed_dict
